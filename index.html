<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ミニメモ（複数）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{--bg0:#070A12;--bg1:#0B1020;--panel:rgba(255,255,255,.06);--panel2:rgba(255,255,255,.08);--stroke:rgba(255,255,255,.10);--stroke2:rgba(255,255,255,.14);--text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.62);--muted2:rgba(255,255,255,.48);--accent:#7C5CFF;--accent2:#2DE2E6;--shadow:0 10px 30px rgba(0,0,0,.35);--radius:16px;--radius2:22px}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",sans-serif;color:var(--text);background:radial-gradient(1200px 600px at 10% 10%, rgba(124,92,255,.22), transparent 50%),radial-gradient(900px 520px at 90% 30%, rgba(45,226,230,.16), transparent 55%),radial-gradient(800px 520px at 40% 90%, rgba(124,92,255,.12), transparent 60%),linear-gradient(180deg, var(--bg0), var(--bg1));padding:18px}
    .topbar{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin:2px 0 14px;flex-wrap:wrap}
    h1{font-size:14px;font-weight:700;letter-spacing:.2px;margin:0;color:rgba(255,255,255,.86)}
    .subtitle{font-size:12px;color:var(--muted2);margin-top:4px;line-height:1.25}
    .topRight{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);backdrop-filter:blur(10px);box-shadow:0 8px 20px rgba(0,0,0,.25);font-size:12px;color:var(--muted);white-space:nowrap}
    .dot{width:8px;height:8px;border-radius:999px;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 0 0 3px rgba(124,92,255,.18)}
    .authBox{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .authLabel{font-size:11px;color:var(--muted2)}
    .app{display:grid;grid-template-columns:380px 1fr;gap:14px;align-items:start}
    @media (max-width:860px){.app{grid-template-columns:1fr}body{padding:14px}}
    .panel{background:var(--panel);border:1px solid var(--stroke);border-radius:var(--radius2);padding:12px;box-shadow:var(--shadow);backdrop-filter:blur(12px)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:10px 11px;font-size:13px;border-radius:12px;cursor:pointer;transition:transform .06s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;user-select:none}
    button:hover{background:rgba(255,255,255,.09);border-color:rgba(255,255,255,.18)} button:active{transform:translateY(1px)}
    #new{background:linear-gradient(135deg, rgba(124,92,255,.95), rgba(45,226,230,.80));border-color:rgba(255,255,255,.14);color:#070A12;font-weight:800}
    #new:hover{filter:brightness(1.03)}
    #pin.isPinned{background:linear-gradient(135deg, rgba(124,92,255,.28), rgba(45,226,230,.22));border-color:rgba(124,92,255,.4);color:#EDE9FE;box-shadow:0 0 0 2px rgba(124,92,255,.12) inset}
    input[type="search"]{width:100%;padding:11px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text);font-size:14px;outline:none}
    .muted{color:var(--muted2);font-size:12px}.count{margin-left:auto;font-size:12px;color:var(--muted);font-family:"JetBrains Mono",monospace}
    .list{margin-top:10px;display:flex;flex-direction:column;gap:8px;max-height:62vh;overflow:auto;padding-right:4px}
    .item{border:1px solid rgba(255,255,255,.10);border-radius:var(--radius);padding:10px;cursor:pointer;background:rgba(255,255,255,.04);position:relative}
    .itemHeader{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .item.active{border-color:rgba(124,92,255,.55);box-shadow:0 0 0 3px rgba(124,92,255,.18),0 10px 25px rgba(0,0,0,.28)}
    .title{font-size:13px;font-weight:750;margin-bottom:3px}.meta{font-size:11px;color:var(--muted2);font-family:"JetBrains Mono",monospace}
    .emptyState{border:1px dashed rgba(255,255,255,.16);border-radius:var(--radius);padding:16px;text-align:center;color:var(--muted2);font-size:12px;background:rgba(255,255,255,.04)}
    textarea{width:100%;min-height:70vh;padding:14px;font-size:16px;line-height:1.6;border-radius:var(--radius2);border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text);outline:none;resize:vertical}
    .status{margin-left:auto;font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05);color:var(--muted);display:inline-flex;align-items:center;gap:8px}
    .ok{color:#6EE7A8;border-color:rgba(110,231,168,.25);background:rgba(110,231,168,.08)} .warn{color:#FBBF24;border-color:rgba(251,191,36,.25);background:rgba(251,191,36,.08)} .err{color:#F87171;border-color:rgba(248,113,113,.25);background:rgba(248,113,113,.08)}
    .syncPill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05)}
    .charCount{margin-top:8px;font-size:12px;color:var(--muted2);font-family:"JetBrains Mono",monospace;text-align:right}
    .editorTabs{display:flex;gap:6px;margin-bottom:8px}
    .editorTab{padding:8px 12px;font-size:12px;border-radius:10px}
    .editorTab.isActive{background:linear-gradient(135deg, rgba(124,92,255,.35), rgba(45,226,230,.26));border-color:rgba(124,92,255,.45);color:#fff}
    .previewPane{display:none;min-height:70vh;padding:14px;border-radius:var(--radius2);border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);overflow:auto;line-height:1.65}
    .previewPane.isActive{display:block}
    #editor.isHidden{display:none}
    .previewPane h1,.previewPane h2,.previewPane h3{margin:1em 0 .45em}
    .previewPane ul,.previewPane ol{padding-left:22px}
    .previewPane pre{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:10px;padding:10px;overflow:auto}
    .previewPane code{font-family:"JetBrains Mono",monospace;font-size:13px}
    .previewPane a{color:#8dd3ff}
    .previewPane .task-item{list-style:none;display:flex;align-items:flex-start;gap:8px;margin:4px 0}
    .previewPane .task-item input{margin-top:3px}
    .snippet{margin-top:7px;font-size:12px;color:var(--muted);line-height:1.45}
    mark{background:rgba(251,191,36,.3);color:#fff;padding:0 2px;border-radius:4px}
    .panelHeader{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .panelTitle{font-size:12px;color:rgba(255,255,255,.78);font-weight:700}
    .filterSelect,.dtInput{padding:9px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text)}
    .notifyBox{margin-bottom:10px;padding:10px;border-radius:12px;border:1px solid var(--stroke);background:rgba(255,255,255,.03)}
    .notifyState{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.04)}
    .notifyState.bad{color:#FBBF24;border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.12)}
    .reminderBadge{font-size:10px;color:#FDE68A;border:1px solid rgba(251,191,36,.38);border-radius:999px;padding:2px 6px}
    .reminderBadge.done{color:#86EFAC;border-color:rgba(134,239,172,.38)}
    .overdue{color:#FCA5A5}
    .shareMeta{margin-top:8px;padding:10px;border-radius:12px;border:1px solid var(--stroke);background:rgba(255,255,255,.03);font-size:12px;color:var(--muted)}
    .shareUrl{font-family:"JetBrains Mono",monospace;word-break:break-all;color:rgba(255,255,255,.8)}
    .readonlyWrap{max-width:920px;margin:0 auto;padding:20px}
    .readonlyTitle{font-size:28px;margin:0 0 6px}
    .readonlyMeta{font-size:12px;color:var(--muted2);margin-bottom:16px}
    .readonlyBody{white-space:pre-wrap;line-height:1.7;border:1px solid var(--stroke);background:rgba(255,255,255,.03);padding:16px;border-radius:16px}
    .warningList{margin:8px 0 0;padding-left:18px;color:#FBBF24}
    .toast{position:fixed;right:18px;bottom:18px;padding:10px 14px;border-radius:12px;background:rgba(7,10,18,.95);border:1px solid var(--stroke2);box-shadow:var(--shadow);font-size:12px;opacity:0;transform:translateY(8px);pointer-events:none;transition:.2s;z-index:50}
    .toast.show{opacity:1;transform:translateY(0)}
    .modal{position:fixed;inset:0;background:rgba(7,10,18,.78);display:none;align-items:center;justify-content:center;padding:18px;z-index:40}
    .modal.isOpen{display:flex}
    .modalCard{width:min(980px,96vw);max-height:86vh;overflow:auto;background:rgba(15,22,42,.95);border:1px solid var(--stroke2);border-radius:18px;padding:14px;box-shadow:var(--shadow)}
    .modalHead{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px}
    .historyLayout{display:grid;grid-template-columns:280px 1fr;gap:10px}
    .historyList{display:flex;flex-direction:column;gap:6px;max-height:60vh;overflow:auto}
    .historyItem{border:1px solid var(--stroke);border-radius:10px;padding:8px;font-size:12px;cursor:pointer;background:rgba(255,255,255,.03)}
    .historyItem.active{border-color:rgba(124,92,255,.65);background:rgba(124,92,255,.18)}
    .compareCols{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .compareCols textarea{min-height:48vh;font-size:13px}
    .snackbar{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);display:none;align-items:center;gap:12px;padding:10px 12px;border-radius:12px;background:rgba(15,22,42,.96);border:1px solid var(--stroke2);z-index:60}
    .snackbar.show{display:flex}
    .trashMeta{font-size:11px;color:var(--muted2)}
    @media (max-width:860px){.historyLayout,.compareCols{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="topbar">
    <div>
      <h1>ミニメモ</h1>
      <div class="subtitle">複数 / 自動保存 / JSON & Markdown / ストレージアダプタ対応</div>
    </div>
    <div class="topRight">
      <div id="storageBadge" class="badge" title="保存先"><span class="dot"></span><span>localStorage</span></div>
      <div id="syncStatus" class="syncPill">同期: 未接続</div>
      <div class="authBox">
        <span id="authLabel" class="authLabel">未ログイン</span>
        <button id="loginEmail">Email</button>
        <button id="loginGoogle">Google</button>
        <button id="loginApple">Apple</button>
        <button id="logout">ログアウト</button>
      </div>
    </div>
  </div>

  <div class="app">
    <div class="panel">
      <div class="panelHeader"><div class="panelTitle">Memos</div><div id="count" class="count"></div></div>
      <div class="row" style="margin-bottom:10px;">
        <button id="new">＋ 新規</button><button id="dup">複製</button><button id="del">削除</button><button id="pin">ピン留め</button><button id="openTrash">ゴミ箱</button>
        <button id="exportJson">JSON</button><button id="exportMd">MD</button><button id="import">インポート</button><button id="migrate">ローカル→クラウド移行</button>
        <input id="importFile" type="file" accept="application/json" hidden /><span id="status" class="status"></span>
      </div>
      <input id="search" type="search" placeholder="検索（タイトル/本文/タグ）" />
      <div class="row" style="margin-top:8px;">
        <label class="muted" for="notebookFilter">Notebook</label>
        <select id="notebookFilter" class="filterSelect">
          <option value="all">すべて</option>
        </select>
        <input id="tagFilter" type="search" placeholder="タグフィルタ（例: work）" style="max-width:180px;" />
        <select id="timeFilter" class="filterSelect">
          <option value="all">期限: すべて</option>
          <option value="overdue">期限切れ</option>
          <option value="today">今日</option>
          <option value="week">今週</option>
        </select>
        <label class="muted" style="display:inline-flex;align-items:center;gap:6px;"><input id="pinnedOnly" type="checkbox" />ピンのみ</label>
      </div>
      <div class="row" style="margin-top:8px;"><div class="muted">Tips: 先頭1行がタイトルになります</div></div>
      <div id="list" class="list"></div>
    </div>
    <div class="panel">
      <div class="panelHeader"><div class="panelTitle">Editor</div><div class="row"><button id="share">共有</button><button id="viewHistory">履歴を見る</button><div id="shortcutHint" class="muted">Ctrl: N新規 S保存 F検索 Pピン E切替 ↑↓移動</div></div></div>
      <div class="notifyBox">
        <div class="row" style="justify-content:space-between;">
          <strong style="font-size:12px;">通知設定</strong>
          <span id="notifyState" class="notifyState">通知: 未確認</span>
        </div>
        <div class="row" style="margin-top:8px;">
          <input id="reminderAt" class="dtInput" type="datetime-local" />
          <button id="requestNotify">通知を許可</button>
          <button id="clearReminder">解除</button>
          <label class="muted" style="display:inline-flex;align-items:center;gap:6px;"><input id="reminderDone" type="checkbox" /> 通知済みにする</label>
        </div>
        <div id="notifyHint" class="muted" style="margin-top:8px;"></div>
      </div>
      <div class="editorTabs" role="tablist" aria-label="エディタ表示切替">
        <button id="tabEdit" class="editorTab isActive" role="tab" aria-selected="true">編集</button>
        <button id="tabPreview" class="editorTab" role="tab" aria-selected="false">プレビュー</button>
      </div>
      <textarea id="editor" placeholder="メモ本文…（先頭1行がタイトルになります）"></textarea>
      <div id="previewPane" class="previewPane" aria-live="polite"></div>
      <div id="charCount" class="charCount"></div>
    </div>
  </div>

  <div id="shareModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="modalHead"><strong>共有設定</strong><button id="closeShare">閉じる</button></div>
      <div class="row" style="margin-bottom:8px;">
        <label class="muted"><input type="radio" name="shareScope" value="private" checked /> 非公開</label>
        <label class="muted"><input type="radio" name="shareScope" value="link" /> リンクを知っている人のみ</label>
      </div>
      <div id="piiWarning" class="muted"></div>
      <div id="shareMeta" class="shareMeta" style="display:none;"></div>
      <div class="row" style="margin-top:10px;">
        <button id="copyShareLink">URLを生成してコピー</button>
        <button id="regenerateShareLink">再生成</button>
        <button id="disableShareLink">共有停止</button>
      </div>
      <div class="muted" style="margin-top:10px;">※再生成または共有停止すると旧リンクは無効になります。</div>
    </div>
  </div>

  <div id="historyModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="modalHead"><strong>履歴</strong><button id="closeHistory">閉じる</button></div>
      <div class="historyLayout">
        <div id="historyList" class="historyList"></div>
        <div>
          <div class="compareCols">
            <div>
              <div class="muted">選択版</div>
              <textarea id="historyPreview" readonly></textarea>
            </div>
            <div>
              <div class="muted">現在版</div>
              <textarea id="historyCurrent" readonly></textarea>
            </div>
          </div>
          <div class="row" style="margin-top:8px;"><button id="restoreVersion">この版に復元</button></div>
        </div>
      </div>
    </div>
  </div>

  <div id="trashModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="modalHead"><strong>ゴミ箱</strong><button id="closeTrash">閉じる</button></div>
      <div id="trashList" class="historyList"></div>
    </div>
  </div>

  <div id="reminderModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="modalHead"><strong>期限到来メモ</strong><button id="closeReminder">閉じる</button></div>
      <div id="reminderList" class="historyList"></div>
    </div>
  </div>

  <div id="snackbar" class="snackbar"><span id="snackbarText"></span><button id="snackbarUndo">Undo</button></div>
  <div id="toast" class="toast"></div>

  <script>
    const STORAGE_KEYS = { localState: "mini_memos_state_v5", auth: "mini_memos_auth_v1", queue: "mini_memos_sync_queue_v1", share: "mini_memos_share_v1", notified: "mini_memos_notified_v1" };
    const HISTORY_LIMIT = 20;
    const TRASH_RETENTION_MS = 1000 * 60 * 60 * 24 * 7;
    const DAY_MS = 1000 * 60 * 60 * 24;

    const uid = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    const now = () => Date.now();
    const scopeLabel = { private: "非公開", link: "リンクを知っている人のみ" };

    const normalizeNotebookId = (id) => (typeof id === "string" && id.trim() ? id.trim() : "default");
    const normalizeHistory = (history) => Array.isArray(history)
      ? history
        .filter((h) => h && typeof h.savedAt === "number" && typeof h.text === "string")
        .sort((a, b) => b.savedAt - a.savedAt)
        .slice(0, HISTORY_LIMIT)
      : [];
    const normalizeImported = (maybe) => Array.isArray(maybe)
      ? maybe.filter((m) => m && typeof m.id === "string" && typeof m.text === "string" && typeof m.updatedAt === "number").map((m) => ({
        id: m.id,
        text: m.text,
        updatedAt: m.updatedAt,
        pinned: Boolean(m.pinned),
        tags: Array.isArray(m.tags) ? m.tags.filter((t) => typeof t === "string").map((t) => t.trim()).filter(Boolean) : [],
        notebookId: normalizeNotebookId(m.notebookId),
        history: normalizeHistory(m.history),
        reminderAt: typeof m.reminderAt === "number" ? m.reminderAt : null,
        reminderDone: Boolean(m.reminderDone),
      }))
      : [];

    const normalizeTrash = (maybe) => Array.isArray(maybe)
      ? maybe.filter((t) => t && t.memo && typeof t.memo.id === "string" && typeof t.deletedAt === "number").map((t) => ({
        memo: normalizeImported([t.memo])[0],
        deletedAt: t.deletedAt,
      })).filter((t) => t.memo)
      : [];

    const purgeExpiredTrash = (trash) => trash.filter((t) => (now() - t.deletedAt) < TRASH_RETENTION_MS);
    const normalizeShareMeta = (maybe) => {
      if (!maybe || typeof maybe !== "object") return {};
      return Object.fromEntries(Object.entries(maybe)
        .filter(([memoId, meta]) => typeof memoId === "string" && meta && typeof meta === "object")
        .map(([memoId, meta]) => [memoId, {
          scope: meta.scope === "link" ? "link" : "private",
          token: typeof meta.token === "string" ? meta.token : "",
          url: typeof meta.url === "string" ? meta.url : "",
          generatedAt: typeof meta.generatedAt === "number" ? meta.generatedAt : 0,
          snapshot: {
            title: typeof meta.snapshot?.title === "string" ? meta.snapshot.title : "（無題）",
            body: typeof meta.snapshot?.body === "string" ? meta.snapshot.body : "",
            updatedAt: typeof meta.snapshot?.updatedAt === "number" ? meta.snapshot.updatedAt : 0,
          },
          revokedTokens: Array.isArray(meta.revokedTokens) ? meta.revokedTokens.filter((t) => typeof t === "string") : [],
          piiWarnings: Array.isArray(meta.piiWarnings) ? meta.piiWarnings.filter((w) => typeof w === "string") : [],
        }]));
    };

    const simpleHash = (text) => {
      let hash = 0;
      for (let i = 0; i < text.length; i += 1) hash = ((hash << 5) - hash + text.charCodeAt(i)) | 0;
      return Math.abs(hash).toString(36);
    };
    const escapeHtml = (text) => String(text ?? "").replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;");

    const detectPII = (text) => {
      const checks = [
        { label: "メールアドレスらしき文字列", re: /[\w.+-]+@[\w.-]+\.[A-Za-z]{2,}/ },
        { label: "電話番号らしき文字列", re: /(\+?\d{1,3}[\s-]?)?(0\d{1,4}[\s-]?\d{1,4}[\s-]?\d{3,4})/ },
        { label: "住所らしき文字列", re: /(都|道|府|県).*(市|区|町|村)/ },
      ];
      return checks.filter((c) => c.re.test(text)).map((c) => c.label);
    };

    const buildShareUrl = (memo, token) => {
      const u = new URL(window.location.href);
      u.searchParams.set("share", token);
      u.searchParams.delete("memo");
      return u.toString();
    };

    const createShareToken = (memo) => `${memo.id}-${simpleHash(memo.text || "")}-${uid()}`;

    const stateSchema = (state) => {
      const memos = normalizeImported(state?.memos);
      const currentId = typeof state?.currentId === "string" ? state.currentId : (memos[0]?.id ?? null);
      const trash = purgeExpiredTrash(normalizeTrash(state?.trash));
      return { memos, currentId, trash };
    };

    const loadAuth = () => {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.auth) || "null") || { loggedIn: false }; }
      catch { return { loggedIn: false }; }
    };

    const saveAuth = (auth) => localStorage.setItem(STORAGE_KEYS.auth, JSON.stringify(auth));

    const localShareStore = {
      load() {
        try { return normalizeShareMeta(JSON.parse(localStorage.getItem(STORAGE_KEYS.share) || "null")); }
        catch { return {}; }
      },
      save(meta) { localStorage.setItem(STORAGE_KEYS.share, JSON.stringify(normalizeShareMeta(meta))); },
    };

    const cloudShareKey = (userId) => `mini_memos_cloud_share_${userId}`;
    const cloudShareStore = {
      load(authState) {
        if (!authState?.loggedIn) return {};
        try { return normalizeShareMeta(JSON.parse(localStorage.getItem(cloudShareKey(authState.id)) || "null")); }
        catch { return {}; }
      },
      save(meta, authState) {
        if (!authState?.loggedIn) throw new Error("not_logged_in");
        if (!navigator.onLine) throw new Error("offline");
        localStorage.setItem(cloudShareKey(authState.id), JSON.stringify(normalizeShareMeta(meta)));
      },
    };

    const localAdapter = {
      name: "local",
      loadState() {
        try { return stateSchema(JSON.parse(localStorage.getItem(STORAGE_KEYS.localState) || "null")); }
        catch { return { memos: [], currentId: null, trash: [] }; }
      },
      saveState(state) { localStorage.setItem(STORAGE_KEYS.localState, JSON.stringify(stateSchema(state))); },
      upsertMemo(memo) {
        const state = this.loadState();
        const idx = state.memos.findIndex((m) => m.id === memo.id);
        if (idx >= 0) state.memos[idx] = memo; else state.memos.push(memo);
        state.currentId = memo.id;
        this.saveState(state);
      },
      deleteMemo(id) {
        const state = this.loadState();
        state.memos = state.memos.filter((m) => m.id !== id);
        if (state.currentId === id) state.currentId = state.memos[0]?.id ?? null;
        this.saveState(state);
      },
    };

    const cloudKey = (userId) => `mini_memos_cloud_${userId}`;
    const cloudAdapter = {
      name: "cloud",
      loadState(auth) {
        if (!auth?.loggedIn) return { memos: [], currentId: null, trash: [] };
        try { return stateSchema(JSON.parse(localStorage.getItem(cloudKey(auth.id)) || "null")); }
        catch { return { memos: [], currentId: null, trash: [] }; }
      },
      saveState(state, auth) {
        if (!auth?.loggedIn) throw new Error("not_logged_in");
        if (!navigator.onLine) throw new Error("offline");
        localStorage.setItem(cloudKey(auth.id), JSON.stringify(stateSchema(state)));
      },
      upsertMemo(memo, auth) {
        const state = this.loadState(auth);
        const idx = state.memos.findIndex((m) => m.id === memo.id);
        if (idx >= 0) {
          const serverMemo = state.memos[idx];
          state.memos[idx] = serverMemo.updatedAt > memo.updatedAt ? serverMemo : memo; // latest-wins
        } else state.memos.push(memo);
        state.currentId = memo.id;
        this.saveState(state, auth);
      },
      deleteMemo(id, auth) {
        const state = this.loadState(auth);
        state.memos = state.memos.filter((m) => m.id !== id);
        if (state.currentId === id) state.currentId = state.memos[0]?.id ?? null;
        this.saveState(state, auth);
      },
    };

    let auth = loadAuth();
    let memos = [];
    let trash = [];
    let currentId = null;
    let shareMeta = {};
    let timer = null;
    let syncState = "idle";
    let selectedHistorySavedAt = null;
    let editorView = "edit";
    let undoTimer = null;
    let notifiedReminderIds = (() => { try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.notified) || "[]") || []; } catch { return []; } })();
    let queue = (() => { try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.queue) || "[]") || []; } catch { return []; } })();

    const $ = (id) => document.getElementById(id);
    const $list = $("list"); const $editor = $("editor"); const $status = $("status"); const $count = $("count"); const $search = $("search");
    const $pin = $("pin"); const $importFile = $("importFile"); const $charCount = $("charCount"); const $authLabel = $("authLabel");
    const $tabEdit = $("tabEdit"); const $tabPreview = $("tabPreview"); const $previewPane = $("previewPane");
    const $storageBadge = $("storageBadge"); const $syncStatus = $("syncStatus"); const $migrate = $("migrate");
    const $notebookFilter = $("notebookFilter"); const $tagFilter = $("tagFilter"); const $pinnedOnly = $("pinnedOnly"); const $timeFilter = $("timeFilter");
    const $historyModal = $("historyModal"); const $historyList = $("historyList"); const $historyPreview = $("historyPreview"); const $historyCurrent = $("historyCurrent");
    const $trashModal = $("trashModal"); const $trashList = $("trashList"); const $reminderModal = $("reminderModal"); const $reminderList = $("reminderList");
    const $shareModal = $("shareModal"); const $shareMeta = $("shareMeta"); const $piiWarning = $("piiWarning");
    const $snackbar = $("snackbar"); const $snackbarText = $("snackbarText"); const $snackbarUndo = $("snackbarUndo"); const $toast = $("toast");
    const $reminderAt = $("reminderAt"); const $reminderDone = $("reminderDone"); const $notifyState = $("notifyState"); const $notifyHint = $("notifyHint");

    const setStatus = (text, kind = "ok", ms = 1200) => { $status.textContent = text; $status.className = `status ${kind}`; if (ms > 0) setTimeout(() => { $status.textContent = ""; $status.className = "status"; }, ms); };
    const setSync = (state, detail = "") => {
      syncState = state;
      const labels = { idle: "同期: 完了", syncing: "同期: 同期中", failed: "同期: 失敗", queued: "同期: オフライン待機" };
      $syncStatus.textContent = detail ? `${labels[state]} (${detail})` : labels[state];
    };

    const formatTime = (ms) => { const d = new Date(ms); const pad = (n) => String(n).padStart(2, "0"); return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`; };
    const closeModal = (el) => el.classList.remove("isOpen");
    const openModal = (el) => el.classList.add("isOpen");
    const showUndoSnackbar = (message, onUndo) => {
      clearTimeout(undoTimer);
      $snackbarText.textContent = message;
      $snackbar.classList.add("show");
      $snackbarUndo.onclick = () => {
        onUndo();
        $snackbar.classList.remove("show");
      };
      undoTimer = setTimeout(() => { $snackbar.classList.remove("show"); }, 6000);
    };

    const showToast = (message) => {
      $toast.textContent = message;
      $toast.classList.add("show");
      setTimeout(() => $toast.classList.remove("show"), 1800);
    };

    const saveNotifiedReminderIds = () => localStorage.setItem(STORAGE_KEYS.notified, JSON.stringify(notifiedReminderIds));
    const normalizeDatetimeLocal = (ms) => {
      const d = new Date(ms);
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    };
    const permissionState = () => (typeof Notification === "undefined" ? "unsupported" : Notification.permission);
    const updateNotifyState = () => {
      const state = permissionState();
      const labels = { granted: "通知: 許可済み", denied: "通知: ブロック中", default: "通知: 未許可", unsupported: "通知: 非対応" };
      $notifyState.textContent = labels[state] || labels.default;
      $notifyState.classList.toggle("bad", state === "denied" || state === "unsupported" || state === "default");
      $notifyHint.textContent = state === "granted"
        ? "通知可能です。期限到来時はブラウザ通知を送ります。"
        : "通知が許可されていないため、期限到来時はアプリ内モーダルでお知らせします。";
    };
    const reminderCategory = (memo) => {
      if (!memo.reminderAt || memo.reminderDone) return null;
      const reminder = memo.reminderAt;
      const current = now();
      if (reminder < current) return "overdue";
      const startToday = new Date();
      startToday.setHours(0, 0, 0, 0);
      const endToday = startToday.getTime() + DAY_MS;
      if (reminder >= startToday.getTime() && reminder < endToday) return "today";
      const dayOfWeek = startToday.getDay();
      const daysUntilWeekEnd = 7 - dayOfWeek;
      const weekEnd = startToday.getTime() + (daysUntilWeekEnd * DAY_MS);
      if (reminder < weekEnd) return "week";
      return null;
    };
    const updateReminderForm = () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      $reminderAt.value = memo.reminderAt ? normalizeDatetimeLocal(memo.reminderAt) : "";
      $reminderDone.checked = Boolean(memo.reminderDone);
      updateNotifyState();
    };

    const loadShareMeta = () => {
      shareMeta = auth.loggedIn ? cloudShareStore.load(auth) : localShareStore.load();
      shareMeta = normalizeShareMeta(shareMeta);
    };

    const saveShareMeta = () => {
      try {
        if (auth.loggedIn) cloudShareStore.save(shareMeta, auth);
        else localShareStore.save(shareMeta);
      } catch (e) {
        if (String(e.message).includes("offline")) {
          localShareStore.save(shareMeta);
          setStatus("共有情報はローカルへ退避しました", "warn", 1700);
        } else setStatus("共有情報の保存に失敗", "err", 1700);
      }
    };

    const renderReadonlySharePage = (shareToken) => {
      const allMeta = { ...localShareStore.load(), ...(auth.loggedIn ? cloudShareStore.load(auth) : {}) };
      const entry = Object.values(allMeta).find((meta) => meta.scope === "link" && meta.token === shareToken && !meta.revokedTokens.includes(shareToken));
      document.body.innerHTML = "";
      const wrap = document.createElement("div");
      wrap.className = "readonlyWrap";
      if (!entry) {
        wrap.innerHTML = `<div class="panel"><h1 class="readonlyTitle">リンクは無効です</h1><div class="readonlyMeta">共有停止または再生成によりこのURLは利用できません。</div></div>`;
        document.body.appendChild(wrap);
        return true;
      }
      wrap.innerHTML = `<div class="panel"><h1 class="readonlyTitle">${escapeHtml(entry.snapshot.title)}</h1><div class="readonlyMeta">最終更新: ${formatTime(entry.snapshot.updatedAt)}</div><div class="readonlyBody">${escapeHtml(entry.snapshot.body)}</div><div class="readonlyMeta" style="margin-top:10px;">このページは閲覧専用です（編集不可）。</div></div>`;
      document.body.appendChild(wrap);
      return true;
    };

    const appendHistorySnapshot = (memo, previousText) => {
      if (typeof previousText !== "string" || previousText === memo.text) return;
      memo.history = normalizeHistory([{ savedAt: now(), text: previousText }, ...(memo.history || [])]);
    };

    const getCurrentMemo = () => memos.find((x) => x.id === currentId);
    const titleOf = (text) => ((text ?? "").split("\n")[0].trim().slice(0, 30) || "（無題）");
    const sortMemos = (items) => [...items].sort((a, b) => (a.pinned !== b.pinned ? (a.pinned ? -1 : 1) : b.updatedAt - a.updatedAt));
    const selectedNotebookId = () => ($notebookFilter.value && $notebookFilter.value !== "all" ? $notebookFilter.value : "default");

    const countTasks = (text) => {
      const matches = String(text ?? "").match(/^\s*[-*]\s+\[( |x|X)\]\s+/gm) || [];
      const done = (String(text ?? "").match(/^\s*[-*]\s+\[(x|X)\]\s+/gm) || []).length;
      return { done, open: matches.length - done, total: matches.length };
    };

    const escapeRegExp = (v) => v.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const highlightTerm = (snippetText, q) => {
      if (!q) return escapeHtml(snippetText);
      const re = new RegExp(`(${escapeRegExp(q)})`, "ig");
      return escapeHtml(snippetText).replace(re, "<mark>$1</mark>");
    };

    const buildSnippet = (memo, q) => {
      if (!q) return "";
      const body = (memo.text || "").replace(/\s+/g, " ").trim();
      const lower = body.toLowerCase();
      const idx = lower.indexOf(q);
      if (idx < 0) return "";
      const start = Math.max(0, idx - 30);
      const end = Math.min(body.length, idx + q.length + 50);
      const prefix = start > 0 ? "…" : "";
      const suffix = end < body.length ? "…" : "";
      return `${prefix}${body.slice(start, end)}${suffix}`;
    };

    const formatInline = (line) => {
      const escaped = escapeHtml(line);
      const withCode = escaped.replace(/`([^`]+)`/g, "<code>$1</code>");
      return withCode.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
    };

    const renderMarkdown = (text) => {
      const lines = String(text ?? "").split("\n");
      const html = [];
      let inCode = false;
      let listType = "";
      const closeList = () => { if (listType) { html.push(`</${listType}>`); listType = ""; } };

      for (let i = 0; i < lines.length; i += 1) {
        const line = lines[i];
        if (line.trim().startsWith("```")) {
          closeList();
          if (!inCode) { html.push("<pre><code>"); inCode = true; }
          else { html.push("</code></pre>"); inCode = false; }
          continue;
        }
        if (inCode) { html.push(`${escapeHtml(line)}\n`); continue; }

        const heading = line.match(/^(#{1,3})\s+(.*)$/);
        if (heading) {
          closeList();
          const level = heading[1].length;
          html.push(`<h${level}>${formatInline(heading[2])}</h${level}>`);
          continue;
        }

        const task = line.match(/^\s*[-*]\s+\[( |x|X)\]\s+(.*)$/);
        if (task) {
          if (listType !== "ul") { closeList(); html.push("<ul>"); listType = "ul"; }
          const checked = task[1].toLowerCase() === "x";
          html.push(`<li class="task-item" data-source-line="${i}"><input type="checkbox" ${checked ? "checked" : ""} data-task-toggle="1" /><span>${formatInline(task[2])}</span></li>`);
          continue;
        }

        const ul = line.match(/^\s*[-*]\s+(.*)$/);
        if (ul) {
          if (listType !== "ul") { closeList(); html.push("<ul>"); listType = "ul"; }
          html.push(`<li>${formatInline(ul[1])}</li>`);
          continue;
        }

        const ol = line.match(/^\s*\d+\.\s+(.*)$/);
        if (ol) {
          if (listType !== "ol") { closeList(); html.push("<ol>"); listType = "ol"; }
          html.push(`<li>${formatInline(ol[1])}</li>`);
          continue;
        }

        closeList();
        if (!line.trim()) html.push("<br />");
        else html.push(`<p>${formatInline(line)}</p>`);
      }
      closeList();
      if (inCode) html.push("</code></pre>");
      return html.join("");
    };

    const renderPreview = () => {
      $previewPane.innerHTML = renderMarkdown($editor.value);
    };

    const setEditorView = (next) => {
      editorView = next === "preview" ? "preview" : "edit";
      const preview = editorView === "preview";
      $editor.classList.toggle("isHidden", preview);
      $previewPane.classList.toggle("isActive", preview);
      $tabEdit.classList.toggle("isActive", !preview);
      $tabPreview.classList.toggle("isActive", preview);
      $tabEdit.setAttribute("aria-selected", String(!preview));
      $tabPreview.setAttribute("aria-selected", String(preview));
      if (preview) renderPreview();
      else $editor.focus();
    };

    const toggleChecklistFromPreview = (lineIndex, checked) => {
      const lines = $editor.value.split("\n");
      const line = lines[lineIndex];
      if (!line) return;
      lines[lineIndex] = line.replace(/^(\s*[-*]\s+\[)( |x|X)(\]\s+)/, (_, a, __, c) => `${a}${checked ? "x" : " "}${c}`);
      $editor.value = lines.join("\n");
      clearTimeout(timer);
      saveCurrentMemo();
      renderPreview();
      updateCharCount();
    };

    const refreshNotebookFilterOptions = () => {
      const prev = $notebookFilter.value || "all";
      const notebooks = ["default", ...new Set(memos.map((m) => normalizeNotebookId(m.notebookId)))].sort();
      $notebookFilter.innerHTML = '<option value="all">すべて</option>' + notebooks.map((n) => `<option value="${n}">${n}</option>`).join("");
      $notebookFilter.value = notebooks.includes(prev) || prev === "all" ? prev : "all";
    };

    const activeAdapter = () => (auth.loggedIn ? cloudAdapter : localAdapter);
    const updateTopbar = () => {
      $authLabel.textContent = auth.loggedIn ? `${auth.provider}: ${auth.email}` : "未ログイン";
      $storageBadge.lastElementChild.textContent = auth.loggedIn ? "Cloud API（ログイン中）" : "localStorage（オフライン）";
      $migrate.style.display = auth.loggedIn ? "inline-flex" : "none";
      if (!auth.loggedIn) setSync("idle", "ローカル");
    };

    const persistQueue = () => localStorage.setItem(STORAGE_KEYS.queue, JSON.stringify(queue));
    const enqueue = (op) => { queue.push(op); persistQueue(); setSync("queued", `${queue.length}件`); };

    const applyRemoteConflict = (remoteMemo) => {
      const i = memos.findIndex((m) => m.id === remoteMemo.id);
      if (i >= 0 && remoteMemo.updatedAt > memos[i].updatedAt) memos[i] = remoteMemo;
    };

    const saveStateThroughAdapter = () => {
      trash = purgeExpiredTrash(trash);
      const state = { memos, currentId, trash };
      try {
        if (auth.loggedIn) {
          setSync("syncing");
          activeAdapter().saveState(state, auth);
          setSync("idle");
        } else {
          activeAdapter().saveState(state);
        }
        return true;
      } catch (e) {
        if (String(e.message).includes("offline")) {
          enqueue({ type: "saveState", state, at: now() });
          localAdapter.saveState(state);
          return true;
        }
        setSync("failed");
        return false;
      }
    };

    const processQueue = () => {
      if (!auth.loggedIn || !navigator.onLine || queue.length === 0) return;
      setSync("syncing", `${queue.length}件`);
      try {
        while (queue.length) {
          const op = queue.shift();
          if (op.type === "saveState") cloudAdapter.saveState(op.state, auth);
          if (op.type === "upsert") cloudAdapter.upsertMemo(op.memo, auth);
          if (op.type === "delete") cloudAdapter.deleteMemo(op.id, auth);
        }
        persistQueue();
        setSync("idle");
      } catch {
        persistQueue();
        setSync("failed");
      }
    };

    const loadInitialState = () => {
      const state = auth.loggedIn ? cloudAdapter.loadState(auth) : localAdapter.loadState();
      loadShareMeta();
      memos = state.memos;
      trash = state.trash;
      currentId = state.currentId;
      if (memos.length === 0) {
        const id = uid();
        memos = [{ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: "default", history: [], reminderAt: null, reminderDone: false }];
        currentId = id;
        saveStateThroughAdapter();
      }
    };

    const saveCurrentMemo = () => {
      const m = getCurrentMemo();
      if (!m) return;
      const before = m.text;
      m.text = $editor.value;
      if (before === m.text) return;
      appendHistorySnapshot(m, before);
      m.updatedAt = now();
      if (auth.loggedIn) {
        try {
          setSync("syncing");
          cloudAdapter.upsertMemo(m, auth);
          const remote = cloudAdapter.loadState(auth).memos.find((x) => x.id === m.id);
          if (remote) applyRemoteConflict(remote); // latest-wins 統合
          setSync("idle");
        } catch (e) {
          if (String(e.message).includes("offline")) {
            enqueue({ type: "upsert", memo: m, at: now() });
            localAdapter.upsertMemo(m);
          } else {
            setSync("failed");
          }
        }
      } else {
        localAdapter.upsertMemo(m);
      }
      render();
      if (editorView === "preview") renderPreview();
    };

    const select = (id) => {
      currentId = id;
      const m = memos.find((x) => x.id === id);
      $editor.value = m ? m.text : "";
      renderPreview();
      saveStateThroughAdapter();
      render();
      updatePinButton();
      updateReminderForm();
      if (editorView === "edit") $editor.focus();
    };

    const filtered = () => {
      const q = ($search.value ?? "").trim().toLowerCase();
      const notebook = $notebookFilter.value;
      const tagQ = ($tagFilter.value ?? "").trim().toLowerCase();
      const pinnedOnly = $pinnedOnly.checked;
      const timeFilter = $timeFilter.value;
      const filteredItems = memos.filter((m) => {
        if (notebook && notebook !== "all" && normalizeNotebookId(m.notebookId) !== notebook) return false;
        if (pinnedOnly && !m.pinned) return false;
        if (tagQ && !m.tags.some((t) => t.toLowerCase().includes(tagQ))) return false;
        if (timeFilter !== "all") {
          const c = reminderCategory(m);
          if (timeFilter === "overdue" && c !== "overdue") return false;
          if (timeFilter === "today" && c !== "today") return false;
          if (timeFilter === "week" && !["today", "week"].includes(c || "")) return false;
        }
        if (!q) return true;
        const target = `${titleOf(m.text)}
${m.text}
${(m.tags || []).join(" ")}`.toLowerCase();
        return target.includes(q);
      });
      return sortMemos(filteredItems);
    };

    const render = () => {
      const items = filtered();
      refreshNotebookFilterOptions();
      $count.textContent = `表示: ${items.length} / 全: ${memos.length}`;
      $list.innerHTML = "";
      if (items.length === 0) { const empty = document.createElement("div"); empty.className = "emptyState"; empty.textContent = "該当するメモがありません。"; $list.appendChild(empty); return; }
      for (const m of items) {
        const div = document.createElement("div");
        div.className = `item${m.id === currentId ? " active" : ""}${m.pinned ? " pinned" : ""}`;
        div.dataset.id = m.id;
        const reminderText = m.reminderAt ? formatTime(m.reminderAt) : "";
        const reminderClass = m.reminderAt && !m.reminderDone && m.reminderAt < now() ? "overdue" : "";
        const reminderBadge = m.reminderAt ? `<span class="reminderBadge${m.reminderDone ? " done" : ""}">${m.reminderDone ? "通知済" : "通知"}</span>` : "";
        const q = ($search.value ?? "").trim().toLowerCase();
        const snippet = buildSnippet(m, q);
        const snippetHtml = snippet ? `<div class="snippet">${highlightTerm(snippet, q)}</div>` : "";
        div.innerHTML = `<div class="itemHeader"><div class="title">${titleOf(m.text)}</div><div class="row">${reminderBadge}<span>${m.pinned ? "★" : "☆"}</span></div></div><div class="meta">${formatTime(m.updatedAt)} ｜ nb:${normalizeNotebookId(m.notebookId)}${m.tags.length ? ` ｜ #${m.tags.join(" #")}` : ""}${reminderText ? ` ｜ <span class="${reminderClass}">${reminderText}</span>` : ""}</div>${snippetHtml}`;
        div.addEventListener("click", () => select(m.id));
        $list.appendChild(div);
      }
      updatePinButton();
      if (editorView === "preview") renderPreview();
    };

    const download = (filename, text, mime) => {
      const blob = new Blob(["\uFEFF" + text], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    };

    const isoTs = () => new Date().toISOString().replaceAll(":", "-");

    const openHistory = () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      const history = memo.history || [];
      $historyList.innerHTML = "";
      if (!history.length) {
        $historyList.innerHTML = '<div class="emptyState">履歴はまだありません。</div>';
        $historyPreview.value = "";
        $historyCurrent.value = memo.text;
        openModal($historyModal);
        return;
      }
      selectedHistorySavedAt = selectedHistorySavedAt && history.some((h) => h.savedAt === selectedHistorySavedAt) ? selectedHistorySavedAt : history[0].savedAt;
      for (const h of history) {
        const row = document.createElement("div");
        row.className = `historyItem${h.savedAt === selectedHistorySavedAt ? " active" : ""}`;
        row.innerHTML = `<div>${formatTime(h.savedAt)}</div><div class="muted">${titleOf(h.text)}</div>`;
        row.addEventListener("click", () => { selectedHistorySavedAt = h.savedAt; openHistory(); });
        $historyList.appendChild(row);
      }
      const selected = history.find((h) => h.savedAt === selectedHistorySavedAt) || history[0];
      $historyPreview.value = selected.text;
      $historyCurrent.value = memo.text;
      openModal($historyModal);
    };

    const renderTrash = () => {
      trash = purgeExpiredTrash(trash);
      $trashList.innerHTML = "";
      if (!trash.length) {
        $trashList.innerHTML = '<div class="emptyState">ゴミ箱は空です。</div>';
        return;
      }
      for (const t of [...trash].sort((a, b) => b.deletedAt - a.deletedAt)) {
        const row = document.createElement("div");
        row.className = "historyItem";
        row.innerHTML = `<div><strong>${titleOf(t.memo.text)}</strong></div><div class="trashMeta">削除: ${formatTime(t.deletedAt)}（${Math.ceil((TRASH_RETENTION_MS - (now() - t.deletedAt)) / (1000 * 60 * 60 * 24))}日後に完全削除）</div>`;
        const restoreBtn = document.createElement("button");
        restoreBtn.textContent = "復元";
        restoreBtn.addEventListener("click", () => {
          trash = trash.filter((x) => x.memo.id !== t.memo.id);
          memos.push(t.memo);
          currentId = t.memo.id;
          $editor.value = t.memo.text;
          saveStateThroughAdapter();
          render();
          renderTrash();
          showUndoSnackbar("復元しました", () => {
            memos = memos.filter((x) => x.id !== t.memo.id);
            trash.push(t);
            if (!memos.length) {
              const id = uid();
              memos.push({ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: selectedNotebookId(), history: [], reminderAt: null, reminderDone: false });
              currentId = id;
            } else currentId = sortMemos(memos)[0].id;
            $editor.value = getCurrentMemo()?.text || "";
            saveStateThroughAdapter();
            render();
            renderTrash();
          });
        });
        const purgeBtn = document.createElement("button");
        purgeBtn.textContent = "完全削除";
        purgeBtn.addEventListener("click", () => {
          if (!confirm("このメモを完全削除します。元に戻せません。")) return;
          const deleted = t;
          trash = trash.filter((x) => x.memo.id !== t.memo.id);
          saveStateThroughAdapter();
          renderTrash();
          showUndoSnackbar("完全削除しました", () => {
            trash.push(deleted);
            saveStateThroughAdapter();
            renderTrash();
          });
        });
        row.appendChild(document.createElement("div")).className = "row";
        row.lastElementChild.append(restoreBtn, purgeBtn);
        $trashList.appendChild(row);
      }
    };

    const renderReminderModal = (dueMemos) => {
      $reminderList.innerHTML = "";
      for (const memo of dueMemos) {
        const row = document.createElement("div");
        row.className = "historyItem";
        row.innerHTML = `<div><strong>${titleOf(memo.text)}</strong></div><div class="muted">期限: ${formatTime(memo.reminderAt)}</div>`;
        const rowButtons = document.createElement("div");
        rowButtons.className = "row";
        const openBtn = document.createElement("button");
        openBtn.textContent = "開く";
        openBtn.addEventListener("click", () => { select(memo.id); closeModal($reminderModal); });
        const doneBtn = document.createElement("button");
        doneBtn.textContent = "通知済みにする";
        doneBtn.addEventListener("click", () => {
          memo.reminderDone = true;
          notifiedReminderIds = [...new Set([...notifiedReminderIds, memo.id])];
          saveNotifiedReminderIds();
          saveStateThroughAdapter();
          render();
          renderReminderModal(dueMemos.filter((m) => !m.reminderDone));
        });
        rowButtons.append(openBtn, doneBtn);
        row.append(rowButtons);
        $reminderList.appendChild(row);
      }
      if (!dueMemos.length) $reminderList.innerHTML = '<div class="emptyState">期限到来メモはありません。</div>';
    };

    const notifyDueMemos = (dueMemos) => {
      const allowed = permissionState() === "granted";
      dueMemos.forEach((memo) => {
        if (allowed) {
          new Notification(`期限: ${titleOf(memo.text)}`, { body: memo.text.slice(0, 80) || "メモを確認してください" });
        }
      });
      if (!allowed && dueMemos.length) {
        renderReminderModal(dueMemos);
        openModal($reminderModal);
        setStatus("通知権限がないため、アプリ内で期限を表示しました", "warn", 2200);
      }
    };

    const checkDueReminders = () => {
      const dueMemos = memos.filter((m) => m.reminderAt && !m.reminderDone && m.reminderAt <= now() && !notifiedReminderIds.includes(m.id));
      if (!dueMemos.length) return;
      notifiedReminderIds = [...new Set([...notifiedReminderIds, ...dueMemos.map((m) => m.id)])];
      saveNotifiedReminderIds();
      notifyDueMemos(dueMemos);
      render();
    };

    const getShareInfo = (memoId) => shareMeta[memoId] || { scope: "private", token: "", url: "", generatedAt: 0, snapshot: { title: "（無題）", body: "", updatedAt: 0 }, revokedTokens: [], piiWarnings: [] };

    const updateShareModal = () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      const info = getShareInfo(memo.id);
      const selected = document.querySelector('input[name="shareScope"]:checked')?.value || info.scope;
      const body = memo.text || "";
      const warnings = detectPII(body);
      $piiWarning.innerHTML = warnings.length ? `<div>注意: 個人情報らしき文字列が含まれている可能性があります。</div><ul class="warningList">${warnings.map((w) => `<li>${w}</li>`).join("")}</ul>` : "";
      if (info.url && info.scope === "link") {
        $shareMeta.style.display = "block";
        $shareMeta.innerHTML = `<div>公開範囲: ${scopeLabel[selected]}</div><div>生成日時: ${formatTime(info.generatedAt)}</div><div class="shareUrl">${info.url}</div>`;
      } else {
        $shareMeta.style.display = "block";
        $shareMeta.innerHTML = `<div>公開範囲: ${scopeLabel[selected]}</div><div>共有リンクは未発行です。</div>`;
      }
    };

    const upsertShareScope = (memoId, scope) => {
      const prev = getShareInfo(memoId);
      shareMeta[memoId] = { ...prev, scope };
      saveShareMeta();
    };

    const invalidateCurrentShare = (memoId) => {
      const prev = getShareInfo(memoId);
      const revoked = prev.token ? [...prev.revokedTokens, prev.token] : prev.revokedTokens;
      shareMeta[memoId] = { ...prev, token: "", url: "", generatedAt: 0, scope: "private", revokedTokens: revoked };
      saveShareMeta();
    };

    const issueShareLink = async (forceRegenerate = false) => {
      const memo = getCurrentMemo();
      if (!memo) return;
      const prev = getShareInfo(memo.id);
      const warnings = detectPII(memo.text || "");
      const revokedTokens = [...prev.revokedTokens];
      if (forceRegenerate && prev.token) revokedTokens.push(prev.token);
      const token = (!forceRegenerate && prev.token) ? prev.token : createShareToken(memo);
      const url = buildShareUrl(memo, token);
      shareMeta[memo.id] = {
        ...prev,
        scope: "link",
        token,
        url,
        generatedAt: now(),
        revokedTokens,
        piiWarnings: warnings,
        snapshot: { title: titleOf(memo.text), body: memo.text, updatedAt: memo.updatedAt || now() },
      };
      saveShareMeta();
      try {
        await navigator.clipboard.writeText(url);
        showToast("共有URLをコピーしました");
      } catch {
        setStatus("コピーに失敗しました", "warn", 1800);
      }
      updateShareModal();
    };

    $("new").addEventListener("click", () => { const id = uid(); memos.push({ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: selectedNotebookId(), history: [], reminderAt: null, reminderDone: false }); select(id); saveStateThroughAdapter(); });
    $("dup").addEventListener("click", () => {
      const m = memos.find((x) => x.id === currentId); if (!m) return;
      const id = uid();
      memos.push({ id, text: m.text, updatedAt: now(), pinned: false, tags: [...(m.tags || [])], notebookId: selectedNotebookId(), history: normalizeHistory(m.history || []), reminderAt: m.reminderAt, reminderDone: Boolean(m.reminderDone) });
      select(id); saveStateThroughAdapter();
    });
    $("del").addEventListener("click", () => {
      const idx = memos.findIndex((x) => x.id === currentId); if (idx === -1) return;
      if (!confirm("このメモをゴミ箱へ移動します。OK？")) return;
      const [removed] = memos.splice(idx, 1);
      delete shareMeta[removed.id];
      saveShareMeta();
      trash.unshift({ memo: removed, deletedAt: now() });
      trash = purgeExpiredTrash(trash);
      if (!memos.length) {
        const id = uid();
        memos.push({ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: selectedNotebookId(), history: [], reminderAt: null, reminderDone: false });
      }
      currentId = sortMemos(memos)[0].id;
      $editor.value = getCurrentMemo()?.text ?? "";
      saveStateThroughAdapter();
      render();
      renderTrash();
    });

    $pin.addEventListener("click", () => { const m = memos.find((x) => x.id === currentId); if (!m) return; m.pinned = !m.pinned; m.updatedAt = now(); saveStateThroughAdapter(); render(); });
    $editor.addEventListener("input", () => { clearTimeout(timer); timer = setTimeout(saveCurrentMemo, 300); updateCharCount(); renderPreview(); });
    $editor.addEventListener("blur", () => { clearTimeout(timer); saveCurrentMemo(); });
    $search.addEventListener("input", render);
    $notebookFilter.addEventListener("change", render);
    $tagFilter.addEventListener("input", render);
    $pinnedOnly.addEventListener("change", render);
    $timeFilter.addEventListener("change", render);

    $tabEdit.addEventListener("click", () => setEditorView("edit"));
    $tabPreview.addEventListener("click", () => setEditorView("preview"));
    $previewPane.addEventListener("change", (event) => {
      const input = event.target;
      if (!(input instanceof HTMLInputElement) || !input.matches("input[data-task-toggle]")) return;
      const row = input.closest("[data-source-line]");
      if (!row) return;
      const lineIndex = Number(row.getAttribute("data-source-line"));
      if (!Number.isFinite(lineIndex)) return;
      toggleChecklistFromPreview(lineIndex, input.checked);
    });

    $reminderAt.addEventListener("change", () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      memo.reminderAt = $reminderAt.value ? new Date($reminderAt.value).getTime() : null;
      memo.reminderDone = false;
      notifiedReminderIds = notifiedReminderIds.filter((id) => id !== memo.id);
      saveNotifiedReminderIds();
      memo.updatedAt = now();
      saveStateThroughAdapter();
      render();
    });
    $reminderDone.addEventListener("change", () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      memo.reminderDone = $reminderDone.checked;
      if (memo.reminderDone) notifiedReminderIds = [...new Set([...notifiedReminderIds, memo.id])];
      else notifiedReminderIds = notifiedReminderIds.filter((id) => id !== memo.id);
      saveNotifiedReminderIds();
      memo.updatedAt = now();
      saveStateThroughAdapter();
      render();
    });
    $("clearReminder").addEventListener("click", () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      memo.reminderAt = null;
      memo.reminderDone = false;
      notifiedReminderIds = notifiedReminderIds.filter((id) => id !== memo.id);
      saveNotifiedReminderIds();
      $reminderAt.value = "";
      $reminderDone.checked = false;
      memo.updatedAt = now();
      saveStateThroughAdapter();
      render();
    });
    $("requestNotify").addEventListener("click", async () => {
      if (typeof Notification === "undefined") return setStatus("このブラウザは通知に非対応です", "warn", 1700);
      const result = await Notification.requestPermission();
      updateNotifyState();
      if (result === "granted") setStatus("通知を許可しました", "ok", 1200);
      else setStatus("通知が許可されていないためアプリ内表示を利用します", "warn", 1800);
    });

    $("share").addEventListener("click", () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      const info = getShareInfo(memo.id);
      const target = document.querySelector(`input[name="shareScope"][value="${info.scope}"]`) || document.querySelector('input[name="shareScope"][value="private"]');
      if (target) target.checked = true;
      updateShareModal();
      openModal($shareModal);
    });
    $("closeShare").addEventListener("click", () => closeModal($shareModal));
    document.querySelectorAll('input[name="shareScope"]').forEach((radio) => radio.addEventListener("change", () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      upsertShareScope(memo.id, radio.value);
      if (radio.value === "private") invalidateCurrentShare(memo.id);
      updateShareModal();
    }));
    $("copyShareLink").addEventListener("click", () => issueShareLink(false));
    $("regenerateShareLink").addEventListener("click", () => issueShareLink(true));
    $("disableShareLink").addEventListener("click", () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      invalidateCurrentShare(memo.id);
      updateShareModal();
      setStatus("共有を停止しました", "ok", 1400);
    });

    $("viewHistory").addEventListener("click", openHistory);
    $("closeHistory").addEventListener("click", () => closeModal($historyModal));
    $("openTrash").addEventListener("click", () => { renderTrash(); openModal($trashModal); });
    $("closeTrash").addEventListener("click", () => closeModal($trashModal));
    $("closeReminder").addEventListener("click", () => closeModal($reminderModal));

    $("restoreVersion").addEventListener("click", () => {
      const memo = getCurrentMemo();
      if (!memo || !selectedHistorySavedAt) return;
      const selected = (memo.history || []).find((h) => h.savedAt === selectedHistorySavedAt);
      if (!selected) return;
      if (!confirm(`履歴版 (${formatTime(selected.savedAt)}) に復元しますか？`)) return;
      const currentText = memo.text;
      memo.text = selected.text;
      memo.updatedAt = now();
      appendHistorySnapshot(memo, currentText);
      $editor.value = memo.text;
      saveStateThroughAdapter();
      render();
      openHistory();
      showUndoSnackbar("履歴から復元しました", () => {
        memo.text = currentText;
        memo.updatedAt = now();
        saveStateThroughAdapter();
        $editor.value = memo.text;
        render();
        openHistory();
      });
    });

    $("exportJson").addEventListener("click", () => { download(`mini-memos-${isoTs()}.json`, JSON.stringify({ version: 8, exportedAt: Date.now(), memos, trash, shareMeta }, null, 2), "application/json;charset=utf-8"); setStatus("JSONを書き出しました"); });
    $("exportMd").addEventListener("click", () => {
      download(`mini-memos-${isoTs()}.md`, $editor.value, "text/markdown;charset=utf-8");
      setStatus("MDを書き出しました");
    });

    $("import").addEventListener("click", () => $importFile.click());
    $importFile.addEventListener("change", async () => {
      const file = $importFile.files?.[0]; if (!file) return;
      try {
        const obj = JSON.parse(await file.text());
        const imported = normalizeImported(obj?.memos);
        if (imported.length === 0) throw new Error("有効なメモが0件です");
        const keepHistory = confirm("インポート時に既存履歴を保持しますか？\nOK: 保持 / キャンセル: 破棄");
        const confirmText = prompt(`現在${memos.length}件を上書きします。実行するには IMPORT と入力してください。\n対象: ${imported.length}件`);
        if (confirmText !== "IMPORT") return setStatus("インポートを中止しました", "warn", 1600);
        if (!keepHistory) imported.forEach((m) => { m.history = []; });
        memos = imported;
        shareMeta = normalizeShareMeta(obj?.shareMeta);
        saveShareMeta();
        trash = [];
        currentId = sortMemos(memos)[0].id;
        $editor.value = memos.find((x) => x.id === currentId)?.text ?? "";
        saveStateThroughAdapter(); render(); setStatus(`インポートしました（履歴:${keepHistory ? "保持" : "破棄"}）`);
      } catch (e) { setStatus(`インポート失敗: ${e.message ?? e}`, "err", 2200); }
      finally { $importFile.value = ""; }
    });

    const migrateLocalToCloud = () => {
      if (!auth.loggedIn) return setStatus("先にログインしてください", "warn");
      const local = localAdapter.loadState();
      const remote = cloudAdapter.loadState(auth);
      if (!local.memos.length) return setStatus("移行するローカルメモがありません", "warn");
      const overwrite = remote.memos.length > 0;
      const msg = overwrite
        ? `クラウドに既存 ${remote.memos.length} 件があります。ローカル ${local.memos.length} 件で上書きしますか？`
        : `ローカル ${local.memos.length} 件をクラウドへ初回移行しますか？`;
      if (!confirm(msg)) return;
      try {
        cloudAdapter.saveState(local, auth);
        shareMeta = localShareStore.load();
        cloudShareStore.save(shareMeta, auth);
        memos = local.memos; trash = local.trash || []; currentId = local.currentId;
        select(currentId || memos[0]?.id);
        setStatus("クラウド移行が完了しました", "ok", 1600);
        setSync("idle");
      } catch (e) {
        if (String(e.message).includes("offline")) {
          enqueue({ type: "saveState", state: local, at: now() });
          setStatus("オフラインのため移行をキューへ追加", "warn", 2000);
        } else setStatus("移行失敗", "err");
      }
    };
    $migrate.addEventListener("click", migrateLocalToCloud);

    const login = (provider) => {
      const email = provider === "email" ? prompt("メールアドレスを入力してください", "user@example.com") : `${provider}_user@example.com`;
      if (!email) return;
      auth = { loggedIn: true, provider, email, id: `${provider}:${email}` };
      saveAuth(auth);
      updateTopbar();
      const remote = cloudAdapter.loadState(auth);
      const local = localAdapter.loadState();
      if (remote.memos.length === 0 && local.memos.length > 0) {
        setStatus("初回ログイン: ローカル→クラウド移行できます", "warn", 2200);
      }
      memos = remote.memos.length ? remote.memos : [{ id: uid(), text: "", updatedAt: now(), pinned: false, tags: [], notebookId: "default", history: [], reminderAt: null, reminderDone: false }];
      shareMeta = cloudShareStore.load(auth);
      trash = remote.trash || [];
      currentId = remote.currentId || memos[0].id;
      processQueue();
      updateNotifyState();
      checkDueReminders();
      select(currentId);
      render();
    };

    $("loginEmail").addEventListener("click", () => login("email"));
    $("loginGoogle").addEventListener("click", () => login("google"));
    $("loginApple").addEventListener("click", () => login("apple"));
    $("logout").addEventListener("click", () => {
      clearTimeout(timer); saveCurrentMemo();
      auth = { loggedIn: false }; saveAuth(auth); updateTopbar();
      const local = localAdapter.loadState(); memos = local.memos; shareMeta = localShareStore.load(); trash = local.trash || []; currentId = local.currentId;
      if (!memos.length) { const id = uid(); memos = [{ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: "default", history: [], reminderAt: null, reminderDone: false }]; currentId = id; localAdapter.saveState({ memos, currentId, trash }); }
      select(currentId); render();
    });

    const updateCharCount = () => { const text = $editor.value; const tasks = countTasks(text); $charCount.textContent = `${text.length} 文字 ｜ ${text ? text.split("\n").length : 0} 行 ｜ 完了 ${tasks.done} / 未完了 ${tasks.open}`; };
    const updatePinButton = () => { const m = memos.find((x) => x.id === currentId); if (!m) return; $pin.textContent = m.pinned ? "ピン解除" : "ピン留め"; $pin.classList.toggle("isPinned", m.pinned); };

    // Keyboard shortcuts
    const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    const modKey = (e) => isMac ? e.metaKey : e.ctrlKey;

    const selectNextMemo = (direction) => {
      const items = filtered();
      if (items.length < 2) return;
      const idx = items.findIndex((m) => m.id === currentId);
      const next = direction === "up"
        ? (idx <= 0 ? items.length - 1 : idx - 1)
        : (idx >= items.length - 1 ? 0 : idx + 1);
      select(items[next].id);
    };

    const isModalOpen = () => [$historyModal, $trashModal, $reminderModal, $shareModal].some((m) => m.classList.contains("isOpen"));
    const closeAllModals = () => [$historyModal, $trashModal, $reminderModal, $shareModal].forEach((m) => closeModal(m));

    const handleKeyboardShortcut = (e) => {
      const activeEl = document.activeElement;
      const inInput = activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA" || activeEl.tagName === "SELECT");

      // Escape: close modal or clear search
      if (e.key === "Escape") {
        if (isModalOpen()) { closeAllModals(); e.preventDefault(); return; }
        if ($search.value) { $search.value = ""; render(); e.preventDefault(); return; }
        if (inInput) { activeEl.blur(); e.preventDefault(); return; }
        return;
      }

      // Modifier key shortcuts
      if (!modKey(e)) return;

      // Ctrl+S: Save (always works, even in textarea)
      if (e.key === "s") {
        e.preventDefault();
        clearTimeout(timer);
        saveCurrentMemo();
        setStatus("保存しました", "ok", 800);
        return;
      }

      // Skip other shortcuts if in input (except editor)
      if (inInput && activeEl !== $editor) return;

      switch (e.key) {
        case "n": // New memo
          e.preventDefault();
          $("new").click();
          showToast("新規メモを作成しました");
          break;
        case "f": // Focus search
          e.preventDefault();
          $search.focus();
          $search.select();
          break;
        case "p": // Toggle pin
          e.preventDefault();
          $pin.click();
          break;
        case "e": // Toggle edit/preview
          e.preventDefault();
          setEditorView(editorView === "edit" ? "preview" : "edit");
          break;
        case "d": // Duplicate
          e.preventDefault();
          $("dup").click();
          showToast("メモを複製しました");
          break;
        case "ArrowUp": // Previous memo
          e.preventDefault();
          selectNextMemo("up");
          break;
        case "ArrowDown": // Next memo
          e.preventDefault();
          selectNextMemo("down");
          break;
      }
    };

    document.addEventListener("keydown", handleKeyboardShortcut);

    window.addEventListener("online", () => { processQueue(); setStatus("オンライン復帰: 同期再開", "ok", 1200); });
    window.addEventListener("offline", () => setSync("queued", "offline"));
    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") { clearTimeout(timer); saveCurrentMemo(); }
      if (document.visibilityState === "visible") checkDueReminders();
    });
    window.addEventListener("beforeunload", () => { clearTimeout(timer); saveCurrentMemo(); });

    const shareToken = new URLSearchParams(window.location.search).get("share");
    if (shareToken) {
      loadShareMeta();
      renderReadonlySharePage(shareToken);
    } else {
      updateTopbar();
      loadInitialState();
      select(currentId);
      render();
      updateCharCount();
      renderPreview();
      setEditorView("edit");
      updateNotifyState();
      processQueue();
      checkDueReminders();
    }
  </script>
</body>
</html>
