<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ミニメモ（複数）</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{--bg0:#070A12;--bg1:#0B1020;--panel:rgba(255,255,255,.06);--panel2:rgba(255,255,255,.08);--stroke:rgba(255,255,255,.10);--stroke2:rgba(255,255,255,.14);--text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.62);--muted2:rgba(255,255,255,.48);--accent:#7C5CFF;--accent2:#2DE2E6;--shadow:0 10px 30px rgba(0,0,0,.35);--radius:16px;--radius2:22px}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",sans-serif;color:var(--text);background:radial-gradient(1200px 600px at 10% 10%, rgba(124,92,255,.22), transparent 50%),radial-gradient(900px 520px at 90% 30%, rgba(45,226,230,.16), transparent 55%),radial-gradient(800px 520px at 40% 90%, rgba(124,92,255,.12), transparent 60%),linear-gradient(180deg, var(--bg0), var(--bg1));padding:18px}
    .topbar{display:flex;align-items:flex-end;justify-content:space-between;gap:12px;margin:2px 0 14px;flex-wrap:wrap}
    h1{font-size:14px;font-weight:700;letter-spacing:.2px;margin:0;color:rgba(255,255,255,.86)}
    .subtitle{font-size:12px;color:var(--muted2);margin-top:4px;line-height:1.25}
    .topRight{display:flex;align-items:center;gap:8px;flex-wrap:wrap;justify-content:flex-end}
    .badge{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);backdrop-filter:blur(10px);box-shadow:0 8px 20px rgba(0,0,0,.25);font-size:12px;color:var(--muted);white-space:nowrap}
    .dot{width:8px;height:8px;border-radius:999px;background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow:0 0 0 3px rgba(124,92,255,.18)}
    .authBox{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
    .authLabel{font-size:11px;color:var(--muted2)}
    .app{display:grid;grid-template-columns:380px 1fr;gap:14px;align-items:start}
    @media (max-width:860px){.app{grid-template-columns:1fr}body{padding:14px}}
    .panel{background:var(--panel);border:1px solid var(--stroke);border-radius:var(--radius2);padding:12px;box-shadow:var(--shadow);backdrop-filter:blur(12px)}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{appearance:none;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:var(--text);padding:10px 11px;font-size:13px;border-radius:12px;cursor:pointer;transition:transform .06s ease, background .2s ease, border-color .2s ease, box-shadow .2s ease;user-select:none}
    button:hover{background:rgba(255,255,255,.09);border-color:rgba(255,255,255,.18)} button:active{transform:translateY(1px)}
    #new{background:linear-gradient(135deg, rgba(124,92,255,.95), rgba(45,226,230,.80));border-color:rgba(255,255,255,.14);color:#070A12;font-weight:800}
    #new:hover{filter:brightness(1.03)}
    #pin.isPinned{background:linear-gradient(135deg, rgba(124,92,255,.28), rgba(45,226,230,.22));border-color:rgba(124,92,255,.4);color:#EDE9FE;box-shadow:0 0 0 2px rgba(124,92,255,.12) inset}
    input[type="search"]{width:100%;padding:11px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text);font-size:14px;outline:none}
    .muted{color:var(--muted2);font-size:12px}.count{margin-left:auto;font-size:12px;color:var(--muted);font-family:"JetBrains Mono",monospace}
    .list{margin-top:10px;display:flex;flex-direction:column;gap:8px;max-height:62vh;overflow:auto;padding-right:4px}
    .item{border:1px solid rgba(255,255,255,.10);border-radius:var(--radius);padding:10px;cursor:pointer;background:rgba(255,255,255,.04);position:relative}
    .itemHeader{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .item.active{border-color:rgba(124,92,255,.55);box-shadow:0 0 0 3px rgba(124,92,255,.18),0 10px 25px rgba(0,0,0,.28)}
    .title{font-size:13px;font-weight:750;margin-bottom:3px}.meta{font-size:11px;color:var(--muted2);font-family:"JetBrains Mono",monospace}
    .emptyState{border:1px dashed rgba(255,255,255,.16);border-radius:var(--radius);padding:16px;text-align:center;color:var(--muted2);font-size:12px;background:rgba(255,255,255,.04)}
    textarea{width:100%;min-height:70vh;padding:14px;font-size:16px;line-height:1.6;border-radius:var(--radius2);border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text);outline:none;resize:vertical}
    .status{margin-left:auto;font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05);color:var(--muted);display:inline-flex;align-items:center;gap:8px}
    .ok{color:#6EE7A8;border-color:rgba(110,231,168,.25);background:rgba(110,231,168,.08)} .warn{color:#FBBF24;border-color:rgba(251,191,36,.25);background:rgba(251,191,36,.08)} .err{color:#F87171;border-color:rgba(248,113,113,.25);background:rgba(248,113,113,.08)}
    .syncPill{font-size:12px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.05)}
    .charCount{margin-top:8px;font-size:12px;color:var(--muted2);font-family:"JetBrains Mono",monospace;text-align:right}
    .panelHeader{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
    .panelTitle{font-size:12px;color:rgba(255,255,255,.78);font-weight:700}
    .modal{position:fixed;inset:0;background:rgba(7,10,18,.78);display:none;align-items:center;justify-content:center;padding:18px;z-index:40}
    .modal.isOpen{display:flex}
    .modalCard{width:min(980px,96vw);max-height:86vh;overflow:auto;background:rgba(15,22,42,.95);border:1px solid var(--stroke2);border-radius:18px;padding:14px;box-shadow:var(--shadow)}
    .modalHead{display:flex;justify-content:space-between;align-items:center;gap:10px;margin-bottom:10px}
    .historyLayout{display:grid;grid-template-columns:280px 1fr;gap:10px}
    .historyList{display:flex;flex-direction:column;gap:6px;max-height:60vh;overflow:auto}
    .historyItem{border:1px solid var(--stroke);border-radius:10px;padding:8px;font-size:12px;cursor:pointer;background:rgba(255,255,255,.03)}
    .historyItem.active{border-color:rgba(124,92,255,.65);background:rgba(124,92,255,.18)}
    .compareCols{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .compareCols textarea{min-height:48vh;font-size:13px}
    .snackbar{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);display:none;align-items:center;gap:12px;padding:10px 12px;border-radius:12px;background:rgba(15,22,42,.96);border:1px solid var(--stroke2);z-index:60}
    .snackbar.show{display:flex}
    .trashMeta{font-size:11px;color:var(--muted2)}
    @media (max-width:860px){.historyLayout,.compareCols{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="topbar">
    <div>
      <h1>ミニメモ</h1>
      <div class="subtitle">複数 / 自動保存 / JSON & Markdown / ストレージアダプタ対応</div>
    </div>
    <div class="topRight">
      <div id="storageBadge" class="badge" title="保存先"><span class="dot"></span><span>localStorage</span></div>
      <div id="syncStatus" class="syncPill">同期: 未接続</div>
      <div class="authBox">
        <span id="authLabel" class="authLabel">未ログイン</span>
        <button id="loginEmail">Email</button>
        <button id="loginGoogle">Google</button>
        <button id="loginApple">Apple</button>
        <button id="logout">ログアウト</button>
      </div>
    </div>
  </div>

  <div class="app">
    <div class="panel">
      <div class="panelHeader"><div class="panelTitle">Memos</div><div id="count" class="count"></div></div>
      <div class="row" style="margin-bottom:10px;">
        <button id="new">＋ 新規</button><button id="dup">複製</button><button id="del">削除</button><button id="pin">ピン留め</button><button id="openTrash">ゴミ箱</button>
        <button id="exportJson">JSON</button><button id="exportMd">MD</button><button id="import">インポート</button><button id="migrate">ローカル→クラウド移行</button>
        <input id="importFile" type="file" accept="application/json" hidden /><span id="status" class="status"></span>
      </div>
      <input id="search" type="search" placeholder="検索（タイトル/本文/タグ）" />
      <div class="row" style="margin-top:8px;">
        <label class="muted" for="notebookFilter">Notebook</label>
        <select id="notebookFilter" style="padding:9px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text);">
          <option value="all">すべて</option>
        </select>
        <input id="tagFilter" type="search" placeholder="タグフィルタ（例: work）" style="max-width:180px;padding:9px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.18);color:var(--text);" />
        <label class="muted" style="display:inline-flex;align-items:center;gap:6px;"><input id="pinnedOnly" type="checkbox" />ピンのみ</label>
      </div>
      <div class="row" style="margin-top:8px;"><div class="muted">Tips: 先頭1行がタイトルになります</div></div>
      <div id="list" class="list"></div>
    </div>
    <div class="panel">
      <div class="panelHeader"><div class="panelTitle">Editor</div><div class="row"><button id="viewHistory">履歴を見る</button><div id="shortcutHint" class="muted">自動保存: 300ms</div></div></div>
      <textarea id="editor" placeholder="メモ本文…（先頭1行がタイトルになります）"></textarea>
      <div id="charCount" class="charCount"></div>
    </div>
  </div>

  <div id="historyModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="modalHead"><strong>履歴</strong><button id="closeHistory">閉じる</button></div>
      <div class="historyLayout">
        <div id="historyList" class="historyList"></div>
        <div>
          <div class="compareCols">
            <div>
              <div class="muted">選択版</div>
              <textarea id="historyPreview" readonly></textarea>
            </div>
            <div>
              <div class="muted">現在版</div>
              <textarea id="historyCurrent" readonly></textarea>
            </div>
          </div>
          <div class="row" style="margin-top:8px;"><button id="restoreVersion">この版に復元</button></div>
        </div>
      </div>
    </div>
  </div>

  <div id="trashModal" class="modal" role="dialog" aria-modal="true">
    <div class="modalCard">
      <div class="modalHead"><strong>ゴミ箱</strong><button id="closeTrash">閉じる</button></div>
      <div id="trashList" class="historyList"></div>
    </div>
  </div>

  <div id="snackbar" class="snackbar"><span id="snackbarText"></span><button id="snackbarUndo">Undo</button></div>

  <script>
    const STORAGE_KEYS = { localState: "mini_memos_state_v4", auth: "mini_memos_auth_v1", queue: "mini_memos_sync_queue_v1" };
    const HISTORY_LIMIT = 20;
    const TRASH_RETENTION_MS = 1000 * 60 * 60 * 24 * 7;

    const uid = () => Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
    const now = () => Date.now();

    const normalizeNotebookId = (id) => (typeof id === "string" && id.trim() ? id.trim() : "default");
    const normalizeHistory = (history) => Array.isArray(history)
      ? history
        .filter((h) => h && typeof h.savedAt === "number" && typeof h.text === "string")
        .sort((a, b) => b.savedAt - a.savedAt)
        .slice(0, HISTORY_LIMIT)
      : [];
    const normalizeImported = (maybe) => Array.isArray(maybe)
      ? maybe.filter((m) => m && typeof m.id === "string" && typeof m.text === "string" && typeof m.updatedAt === "number").map((m) => ({
        id: m.id,
        text: m.text,
        updatedAt: m.updatedAt,
        pinned: Boolean(m.pinned),
        tags: Array.isArray(m.tags) ? m.tags.filter((t) => typeof t === "string").map((t) => t.trim()).filter(Boolean) : [],
        notebookId: normalizeNotebookId(m.notebookId),
        history: normalizeHistory(m.history),
      }))
      : [];

    const normalizeTrash = (maybe) => Array.isArray(maybe)
      ? maybe.filter((t) => t && t.memo && typeof t.memo.id === "string" && typeof t.deletedAt === "number").map((t) => ({
        memo: normalizeImported([t.memo])[0],
        deletedAt: t.deletedAt,
      })).filter((t) => t.memo)
      : [];

    const purgeExpiredTrash = (trash) => trash.filter((t) => (now() - t.deletedAt) < TRASH_RETENTION_MS);

    const stateSchema = (state) => {
      const memos = normalizeImported(state?.memos);
      const currentId = typeof state?.currentId === "string" ? state.currentId : (memos[0]?.id ?? null);
      const trash = purgeExpiredTrash(normalizeTrash(state?.trash));
      return { memos, currentId, trash };
    };

    const loadAuth = () => {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.auth) || "null") || { loggedIn: false }; }
      catch { return { loggedIn: false }; }
    };

    const saveAuth = (auth) => localStorage.setItem(STORAGE_KEYS.auth, JSON.stringify(auth));

    const localAdapter = {
      name: "local",
      loadState() {
        try { return stateSchema(JSON.parse(localStorage.getItem(STORAGE_KEYS.localState) || "null")); }
        catch { return { memos: [], currentId: null, trash: [] }; }
      },
      saveState(state) { localStorage.setItem(STORAGE_KEYS.localState, JSON.stringify(stateSchema(state))); },
      upsertMemo(memo) {
        const state = this.loadState();
        const idx = state.memos.findIndex((m) => m.id === memo.id);
        if (idx >= 0) state.memos[idx] = memo; else state.memos.push(memo);
        state.currentId = memo.id;
        this.saveState(state);
      },
      deleteMemo(id) {
        const state = this.loadState();
        state.memos = state.memos.filter((m) => m.id !== id);
        if (state.currentId === id) state.currentId = state.memos[0]?.id ?? null;
        this.saveState(state);
      },
    };

    const cloudKey = (userId) => `mini_memos_cloud_${userId}`;
    const cloudAdapter = {
      name: "cloud",
      loadState(auth) {
        if (!auth?.loggedIn) return { memos: [], currentId: null, trash: [] };
        try { return stateSchema(JSON.parse(localStorage.getItem(cloudKey(auth.id)) || "null")); }
        catch { return { memos: [], currentId: null, trash: [] }; }
      },
      saveState(state, auth) {
        if (!auth?.loggedIn) throw new Error("not_logged_in");
        if (!navigator.onLine) throw new Error("offline");
        localStorage.setItem(cloudKey(auth.id), JSON.stringify(stateSchema(state)));
      },
      upsertMemo(memo, auth) {
        const state = this.loadState(auth);
        const idx = state.memos.findIndex((m) => m.id === memo.id);
        if (idx >= 0) {
          const serverMemo = state.memos[idx];
          state.memos[idx] = serverMemo.updatedAt > memo.updatedAt ? serverMemo : memo; // latest-wins
        } else state.memos.push(memo);
        state.currentId = memo.id;
        this.saveState(state, auth);
      },
      deleteMemo(id, auth) {
        const state = this.loadState(auth);
        state.memos = state.memos.filter((m) => m.id !== id);
        if (state.currentId === id) state.currentId = state.memos[0]?.id ?? null;
        this.saveState(state, auth);
      },
    };

    let auth = loadAuth();
    let memos = [];
    let trash = [];
    let currentId = null;
    let timer = null;
    let syncState = "idle";
    let selectedHistorySavedAt = null;
    let undoTimer = null;
    let queue = (() => { try { return JSON.parse(localStorage.getItem(STORAGE_KEYS.queue) || "[]") || []; } catch { return []; } })();

    const $ = (id) => document.getElementById(id);
    const $list = $("list"); const $editor = $("editor"); const $status = $("status"); const $count = $("count"); const $search = $("search");
    const $pin = $("pin"); const $importFile = $("importFile"); const $charCount = $("charCount"); const $authLabel = $("authLabel");
    const $storageBadge = $("storageBadge"); const $syncStatus = $("syncStatus"); const $migrate = $("migrate");
    const $notebookFilter = $("notebookFilter"); const $tagFilter = $("tagFilter"); const $pinnedOnly = $("pinnedOnly");
    const $historyModal = $("historyModal"); const $historyList = $("historyList"); const $historyPreview = $("historyPreview"); const $historyCurrent = $("historyCurrent");
    const $trashModal = $("trashModal"); const $trashList = $("trashList");
    const $snackbar = $("snackbar"); const $snackbarText = $("snackbarText"); const $snackbarUndo = $("snackbarUndo");

    const setStatus = (text, kind = "ok", ms = 1200) => { $status.textContent = text; $status.className = `status ${kind}`; if (ms > 0) setTimeout(() => { $status.textContent = ""; $status.className = "status"; }, ms); };
    const setSync = (state, detail = "") => {
      syncState = state;
      const labels = { idle: "同期: 完了", syncing: "同期: 同期中", failed: "同期: 失敗", queued: "同期: オフライン待機" };
      $syncStatus.textContent = detail ? `${labels[state]} (${detail})` : labels[state];
    };

    const formatTime = (ms) => { const d = new Date(ms); const pad = (n) => String(n).padStart(2, "0"); return `${d.getFullYear()}/${pad(d.getMonth() + 1)}/${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`; };
    const closeModal = (el) => el.classList.remove("isOpen");
    const openModal = (el) => el.classList.add("isOpen");
    const showUndoSnackbar = (message, onUndo) => {
      clearTimeout(undoTimer);
      $snackbarText.textContent = message;
      $snackbar.classList.add("show");
      $snackbarUndo.onclick = () => {
        onUndo();
        $snackbar.classList.remove("show");
      };
      undoTimer = setTimeout(() => { $snackbar.classList.remove("show"); }, 6000);
    };

    const appendHistorySnapshot = (memo, previousText) => {
      if (typeof previousText !== "string" || previousText === memo.text) return;
      memo.history = normalizeHistory([{ savedAt: now(), text: previousText }, ...(memo.history || [])]);
    };

    const getCurrentMemo = () => memos.find((x) => x.id === currentId);
    const titleOf = (text) => ((text ?? "").split("\n")[0].trim().slice(0, 30) || "（無題）");
    const sortMemos = (items) => [...items].sort((a, b) => (a.pinned !== b.pinned ? (a.pinned ? -1 : 1) : b.updatedAt - a.updatedAt));
    const selectedNotebookId = () => ($notebookFilter.value && $notebookFilter.value !== "all" ? $notebookFilter.value : "default");

    const refreshNotebookFilterOptions = () => {
      const prev = $notebookFilter.value || "all";
      const notebooks = ["default", ...new Set(memos.map((m) => normalizeNotebookId(m.notebookId)))].sort();
      $notebookFilter.innerHTML = '<option value="all">すべて</option>' + notebooks.map((n) => `<option value="${n}">${n}</option>`).join("");
      $notebookFilter.value = notebooks.includes(prev) || prev === "all" ? prev : "all";
    };

    const activeAdapter = () => (auth.loggedIn ? cloudAdapter : localAdapter);
    const updateTopbar = () => {
      $authLabel.textContent = auth.loggedIn ? `${auth.provider}: ${auth.email}` : "未ログイン";
      $storageBadge.lastElementChild.textContent = auth.loggedIn ? "Cloud API（ログイン中）" : "localStorage（オフライン）";
      $migrate.style.display = auth.loggedIn ? "inline-flex" : "none";
      if (!auth.loggedIn) setSync("idle", "ローカル");
    };

    const persistQueue = () => localStorage.setItem(STORAGE_KEYS.queue, JSON.stringify(queue));
    const enqueue = (op) => { queue.push(op); persistQueue(); setSync("queued", `${queue.length}件`); };

    const applyRemoteConflict = (remoteMemo) => {
      const i = memos.findIndex((m) => m.id === remoteMemo.id);
      if (i >= 0 && remoteMemo.updatedAt > memos[i].updatedAt) memos[i] = remoteMemo;
    };

    const saveStateThroughAdapter = () => {
      trash = purgeExpiredTrash(trash);
      const state = { memos, currentId, trash };
      try {
        if (auth.loggedIn) {
          setSync("syncing");
          activeAdapter().saveState(state, auth);
          setSync("idle");
        } else {
          activeAdapter().saveState(state);
        }
        return true;
      } catch (e) {
        if (String(e.message).includes("offline")) {
          enqueue({ type: "saveState", state, at: now() });
          localAdapter.saveState(state);
          return true;
        }
        setSync("failed");
        return false;
      }
    };

    const processQueue = () => {
      if (!auth.loggedIn || !navigator.onLine || queue.length === 0) return;
      setSync("syncing", `${queue.length}件`);
      try {
        while (queue.length) {
          const op = queue.shift();
          if (op.type === "saveState") cloudAdapter.saveState(op.state, auth);
          if (op.type === "upsert") cloudAdapter.upsertMemo(op.memo, auth);
          if (op.type === "delete") cloudAdapter.deleteMemo(op.id, auth);
        }
        persistQueue();
        setSync("idle");
      } catch {
        persistQueue();
        setSync("failed");
      }
    };

    const loadInitialState = () => {
      const state = auth.loggedIn ? cloudAdapter.loadState(auth) : localAdapter.loadState();
      memos = state.memos;
      trash = state.trash;
      currentId = state.currentId;
      if (memos.length === 0) {
        const id = uid();
        memos = [{ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: "default", history: [] }];
        currentId = id;
        saveStateThroughAdapter();
      }
    };

    const saveCurrentMemo = () => {
      const m = getCurrentMemo();
      if (!m) return;
      const before = m.text;
      m.text = $editor.value;
      if (before === m.text) return;
      appendHistorySnapshot(m, before);
      m.updatedAt = now();
      if (auth.loggedIn) {
        try {
          setSync("syncing");
          cloudAdapter.upsertMemo(m, auth);
          const remote = cloudAdapter.loadState(auth).memos.find((x) => x.id === m.id);
          if (remote) applyRemoteConflict(remote); // latest-wins 統合
          setSync("idle");
        } catch (e) {
          if (String(e.message).includes("offline")) {
            enqueue({ type: "upsert", memo: m, at: now() });
            localAdapter.upsertMemo(m);
          } else {
            setSync("failed");
          }
        }
      } else {
        localAdapter.upsertMemo(m);
      }
      render();
    };

    const select = (id) => {
      currentId = id;
      const m = memos.find((x) => x.id === id);
      $editor.value = m ? m.text : "";
      saveStateThroughAdapter();
      render();
      updatePinButton();
      $editor.focus();
    };

    const filtered = () => {
      const q = ($search.value ?? "").trim().toLowerCase();
      const notebook = $notebookFilter.value;
      const tagQ = ($tagFilter.value ?? "").trim().toLowerCase();
      const pinnedOnly = $pinnedOnly.checked;
      const filteredItems = memos.filter((m) => {
        if (notebook && notebook !== "all" && normalizeNotebookId(m.notebookId) !== notebook) return false;
        if (pinnedOnly && !m.pinned) return false;
        if (tagQ && !m.tags.some((t) => t.toLowerCase().includes(tagQ))) return false;
        if (!q) return true;
        const target = `${titleOf(m.text)}\n${m.text}\n${(m.tags || []).join(" ")}`.toLowerCase();
        return target.includes(q);
      });
      return sortMemos(filteredItems);
    };

    const render = () => {
      const items = filtered();
      refreshNotebookFilterOptions();
      $count.textContent = `表示: ${items.length} / 全: ${memos.length}`;
      $list.innerHTML = "";
      if (items.length === 0) { const empty = document.createElement("div"); empty.className = "emptyState"; empty.textContent = "該当するメモがありません。"; $list.appendChild(empty); return; }
      for (const m of items) {
        const div = document.createElement("div");
        div.className = `item${m.id === currentId ? " active" : ""}${m.pinned ? " pinned" : ""}`;
        div.dataset.id = m.id;
        div.innerHTML = `<div class="itemHeader"><div class="title">${titleOf(m.text)}</div><div>${m.pinned ? "★" : "☆"}</div></div><div class="meta">${formatTime(m.updatedAt)} ｜ nb:${normalizeNotebookId(m.notebookId)}${m.tags.length ? ` ｜ #${m.tags.join(" #")}` : ""}</div>`;
        div.addEventListener("click", () => select(m.id));
        $list.appendChild(div);
      }
      updatePinButton();
    };

    const download = (filename, text, mime) => {
      const blob = new Blob(["\uFEFF" + text], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a"); a.href = url; a.download = filename; a.click();
      URL.revokeObjectURL(url);
    };

    const isoTs = () => new Date().toISOString().replaceAll(":", "-");

    const openHistory = () => {
      const memo = getCurrentMemo();
      if (!memo) return;
      const history = memo.history || [];
      $historyList.innerHTML = "";
      if (!history.length) {
        $historyList.innerHTML = '<div class="emptyState">履歴はまだありません。</div>';
        $historyPreview.value = "";
        $historyCurrent.value = memo.text;
        openModal($historyModal);
        return;
      }
      selectedHistorySavedAt = selectedHistorySavedAt && history.some((h) => h.savedAt === selectedHistorySavedAt) ? selectedHistorySavedAt : history[0].savedAt;
      for (const h of history) {
        const row = document.createElement("div");
        row.className = `historyItem${h.savedAt === selectedHistorySavedAt ? " active" : ""}`;
        row.innerHTML = `<div>${formatTime(h.savedAt)}</div><div class="muted">${titleOf(h.text)}</div>`;
        row.addEventListener("click", () => { selectedHistorySavedAt = h.savedAt; openHistory(); });
        $historyList.appendChild(row);
      }
      const selected = history.find((h) => h.savedAt === selectedHistorySavedAt) || history[0];
      $historyPreview.value = selected.text;
      $historyCurrent.value = memo.text;
      openModal($historyModal);
    };

    const renderTrash = () => {
      trash = purgeExpiredTrash(trash);
      $trashList.innerHTML = "";
      if (!trash.length) {
        $trashList.innerHTML = '<div class="emptyState">ゴミ箱は空です。</div>';
        return;
      }
      for (const t of [...trash].sort((a, b) => b.deletedAt - a.deletedAt)) {
        const row = document.createElement("div");
        row.className = "historyItem";
        row.innerHTML = `<div><strong>${titleOf(t.memo.text)}</strong></div><div class="trashMeta">削除: ${formatTime(t.deletedAt)}（${Math.ceil((TRASH_RETENTION_MS - (now() - t.deletedAt)) / (1000 * 60 * 60 * 24))}日後に完全削除）</div>`;
        const restoreBtn = document.createElement("button");
        restoreBtn.textContent = "復元";
        restoreBtn.addEventListener("click", () => {
          trash = trash.filter((x) => x.memo.id !== t.memo.id);
          memos.push(t.memo);
          currentId = t.memo.id;
          $editor.value = t.memo.text;
          saveStateThroughAdapter();
          render();
          renderTrash();
          showUndoSnackbar("復元しました", () => {
            memos = memos.filter((x) => x.id !== t.memo.id);
            trash.push(t);
            if (!memos.length) {
              const id = uid();
              memos.push({ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: selectedNotebookId(), history: [] });
              currentId = id;
            } else currentId = sortMemos(memos)[0].id;
            $editor.value = getCurrentMemo()?.text || "";
            saveStateThroughAdapter();
            render();
            renderTrash();
          });
        });
        const purgeBtn = document.createElement("button");
        purgeBtn.textContent = "完全削除";
        purgeBtn.addEventListener("click", () => {
          if (!confirm("このメモを完全削除します。元に戻せません。")) return;
          const deleted = t;
          trash = trash.filter((x) => x.memo.id !== t.memo.id);
          saveStateThroughAdapter();
          renderTrash();
          showUndoSnackbar("完全削除しました", () => {
            trash.push(deleted);
            saveStateThroughAdapter();
            renderTrash();
          });
        });
        row.appendChild(document.createElement("div")).className = "row";
        row.lastElementChild.append(restoreBtn, purgeBtn);
        $trashList.appendChild(row);
      }
    };

    $("new").addEventListener("click", () => { const id = uid(); memos.push({ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: selectedNotebookId(), history: [] }); select(id); saveStateThroughAdapter(); });
    $("dup").addEventListener("click", () => {
      const m = memos.find((x) => x.id === currentId); if (!m) return;
      const id = uid();
      memos.push({ id, text: m.text, updatedAt: now(), pinned: false, tags: [...(m.tags || [])], notebookId: selectedNotebookId(), history: normalizeHistory(m.history || []) });
      select(id); saveStateThroughAdapter();
    });
    $("del").addEventListener("click", () => {
      const idx = memos.findIndex((x) => x.id === currentId); if (idx === -1) return;
      if (!confirm("このメモをゴミ箱へ移動します。OK？")) return;
      const [removed] = memos.splice(idx, 1);
      trash.unshift({ memo: removed, deletedAt: now() });
      trash = purgeExpiredTrash(trash);
      if (!memos.length) {
        const id = uid();
        memos.push({ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: selectedNotebookId(), history: [] });
      }
      currentId = sortMemos(memos)[0].id;
      $editor.value = getCurrentMemo()?.text ?? "";
      saveStateThroughAdapter();
      render();
      renderTrash();
    });

    $pin.addEventListener("click", () => { const m = memos.find((x) => x.id === currentId); if (!m) return; m.pinned = !m.pinned; m.updatedAt = now(); saveStateThroughAdapter(); render(); });
    $editor.addEventListener("input", () => { clearTimeout(timer); timer = setTimeout(saveCurrentMemo, 300); updateCharCount(); });
    $editor.addEventListener("blur", () => { clearTimeout(timer); saveCurrentMemo(); });
    $search.addEventListener("input", render);
    $notebookFilter.addEventListener("change", render);
    $tagFilter.addEventListener("input", render);
    $pinnedOnly.addEventListener("change", render);


    $("viewHistory").addEventListener("click", openHistory);
    $("closeHistory").addEventListener("click", () => closeModal($historyModal));
    $("openTrash").addEventListener("click", () => { renderTrash(); openModal($trashModal); });
    $("closeTrash").addEventListener("click", () => closeModal($trashModal));

    $("restoreVersion").addEventListener("click", () => {
      const memo = getCurrentMemo();
      if (!memo || !selectedHistorySavedAt) return;
      const selected = (memo.history || []).find((h) => h.savedAt === selectedHistorySavedAt);
      if (!selected) return;
      if (!confirm(`履歴版 (${formatTime(selected.savedAt)}) に復元しますか？`)) return;
      const currentText = memo.text;
      memo.text = selected.text;
      memo.updatedAt = now();
      appendHistorySnapshot(memo, currentText);
      $editor.value = memo.text;
      saveStateThroughAdapter();
      render();
      openHistory();
      showUndoSnackbar("履歴から復元しました", () => {
        memo.text = currentText;
        memo.updatedAt = now();
        saveStateThroughAdapter();
        $editor.value = memo.text;
        render();
        openHistory();
      });
    });

    $("exportJson").addEventListener("click", () => { download(`mini-memos-${isoTs()}.json`, JSON.stringify({ version: 6, exportedAt: Date.now(), memos, trash }, null, 2), "application/json;charset=utf-8"); setStatus("JSONを書き出しました"); });
    $("exportMd").addEventListener("click", () => {
      const md = sortMemos(memos).map((m) => `## ${titleOf(m.text)}\nUpdatedAt: ${formatTime(m.updatedAt)}\nNotebook: ${normalizeNotebookId(m.notebookId)}\nTags: ${(m.tags || []).join(", ")}\n\n${m.text}\n`).join("\n---\n\n");
      download(`mini-memos-${isoTs()}.md`, `# ミニメモ\n\n${md}`, "text/markdown;charset=utf-8");
      setStatus("MDを書き出しました");
    });

    $("import").addEventListener("click", () => $importFile.click());
    $importFile.addEventListener("change", async () => {
      const file = $importFile.files?.[0]; if (!file) return;
      try {
        const obj = JSON.parse(await file.text());
        const imported = normalizeImported(obj?.memos);
        if (imported.length === 0) throw new Error("有効なメモが0件です");
        const keepHistory = confirm("インポート時に既存履歴を保持しますか？\nOK: 保持 / キャンセル: 破棄");
        const confirmText = prompt(`現在${memos.length}件を上書きします。実行するには IMPORT と入力してください。\n対象: ${imported.length}件`);
        if (confirmText !== "IMPORT") return setStatus("インポートを中止しました", "warn", 1600);
        if (!keepHistory) imported.forEach((m) => { m.history = []; });
        memos = imported;
        trash = [];
        currentId = sortMemos(memos)[0].id;
        $editor.value = memos.find((x) => x.id === currentId)?.text ?? "";
        saveStateThroughAdapter(); render(); setStatus(`インポートしました（履歴:${keepHistory ? "保持" : "破棄"}）`);
      } catch (e) { setStatus(`インポート失敗: ${e.message ?? e}`, "err", 2200); }
      finally { $importFile.value = ""; }
    });

    const migrateLocalToCloud = () => {
      if (!auth.loggedIn) return setStatus("先にログインしてください", "warn");
      const local = localAdapter.loadState();
      const remote = cloudAdapter.loadState(auth);
      if (!local.memos.length) return setStatus("移行するローカルメモがありません", "warn");
      const overwrite = remote.memos.length > 0;
      const msg = overwrite
        ? `クラウドに既存 ${remote.memos.length} 件があります。ローカル ${local.memos.length} 件で上書きしますか？`
        : `ローカル ${local.memos.length} 件をクラウドへ初回移行しますか？`;
      if (!confirm(msg)) return;
      try {
        cloudAdapter.saveState(local, auth);
        memos = local.memos; trash = local.trash || []; currentId = local.currentId;
        select(currentId || memos[0]?.id);
        setStatus("クラウド移行が完了しました", "ok", 1600);
        setSync("idle");
      } catch (e) {
        if (String(e.message).includes("offline")) {
          enqueue({ type: "saveState", state: local, at: now() });
          setStatus("オフラインのため移行をキューへ追加", "warn", 2000);
        } else setStatus("移行失敗", "err");
      }
    };
    $migrate.addEventListener("click", migrateLocalToCloud);

    const login = (provider) => {
      const email = provider === "email" ? prompt("メールアドレスを入力してください", "user@example.com") : `${provider}_user@example.com`;
      if (!email) return;
      auth = { loggedIn: true, provider, email, id: `${provider}:${email}` };
      saveAuth(auth);
      updateTopbar();
      const remote = cloudAdapter.loadState(auth);
      const local = localAdapter.loadState();
      if (remote.memos.length === 0 && local.memos.length > 0) {
        setStatus("初回ログイン: ローカル→クラウド移行できます", "warn", 2200);
      }
      memos = remote.memos.length ? remote.memos : [{ id: uid(), text: "", updatedAt: now(), pinned: false, tags: [], notebookId: "default", history: [] }];
      trash = remote.trash || [];
      currentId = remote.currentId || memos[0].id;
      processQueue();
      select(currentId);
      render();
    };

    $("loginEmail").addEventListener("click", () => login("email"));
    $("loginGoogle").addEventListener("click", () => login("google"));
    $("loginApple").addEventListener("click", () => login("apple"));
    $("logout").addEventListener("click", () => {
      clearTimeout(timer); saveCurrentMemo();
      auth = { loggedIn: false }; saveAuth(auth); updateTopbar();
      const local = localAdapter.loadState(); memos = local.memos; trash = local.trash || []; currentId = local.currentId;
      if (!memos.length) { const id = uid(); memos = [{ id, text: "", updatedAt: now(), pinned: false, tags: [], notebookId: "default", history: [] }]; currentId = id; localAdapter.saveState({ memos, currentId, trash }); }
      select(currentId); render();
    });

    const updateCharCount = () => { const text = $editor.value; $charCount.textContent = `${text.length} 文字 ｜ ${text ? text.split("\n").length : 0} 行`; };
    const updatePinButton = () => { const m = memos.find((x) => x.id === currentId); if (!m) return; $pin.textContent = m.pinned ? "ピン解除" : "ピン留め"; $pin.classList.toggle("isPinned", m.pinned); };

    window.addEventListener("online", () => { processQueue(); setStatus("オンライン復帰: 同期再開", "ok", 1200); });
    window.addEventListener("offline", () => setSync("queued", "offline"));
    document.addEventListener("visibilitychange", () => { if (document.visibilityState === "hidden") { clearTimeout(timer); saveCurrentMemo(); } });
    window.addEventListener("beforeunload", () => { clearTimeout(timer); saveCurrentMemo(); });

    updateTopbar();
    loadInitialState();
    select(currentId);
    render();
    updateCharCount();
    processQueue();
  </script>
</body>
</html>
